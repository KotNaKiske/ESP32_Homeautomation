long lastms = 0;
void task_structure(void* parameter) {
  while (true) {
    if (millis() < 1000)
      lastms = 0;
    if (millis() > lastms) {
      lastms = millis() + 1000;
      if (servo.servoms != -1)
        if (millis() - 9000 > servo.servoms) {
          servo.servo.write(servo.off);
          servo.servoms = -1;
        }
      for (byte i = 0; i < lenrele; i++) {
        if (rele[i].off != -1) {
          if ((i == 2) && ((rele[i].off - lastms) > 29000) && ((rele[i].off - lastms) < 30000)) blazer();
          if (rele[i].off < lastms) {
            rele[i].off = -1;
            if (rele[i].b) {
              //if ((i == 0) && (servo.offms < millis()) && (servo.offms != -1)) {
              if ((i == 0) && (servo.servoms == -1)) {
                if (servo.b)
                  servo.offms = millis();
                //servo.timer = millis();
              }
              swrele(i, false);
            }
          }
        }
        if (rele[i].on != -1)
          if (rele[i].on < lastms) {
            rele[i].on = -1;
            if (!rele[i].b) {
              swrele(i, true);
            }
          }
      }
      if ((servo.offms != -1) && (millis() - 1000 > servo.offms)) {
        servo.servo.write(servo.on);
        servo.servoms = millis();
        servo.offms = -1;
      }
    }
    if (bletime != -1) {
      blesend(blemess);
      if (millis() - 500 > bletime) {
        blestop();
      };
    }
    vTaskDelay(100 / portTICK_RATE_MS);
  }
}
void blestop() {
  Serial.println("blestop");
  esp_ble_gap_stop_advertising();
  bletime = -1;
}
void httpsend() {
  if (HTTPClient.connect("192.168.0.5", 80)) {
    HTTPClient.println((String)"GET /relays?switch=1," + (au[0] ? "1" : "0") + "," + (au[2] ? "1" : "0") + ",0 HTTP/1.1");
    //    HTTPClient.println("GET /relays?toggle=0,1,0,0 HTTP/1.1");
    HTTPClient.println("Host: 192.168.0.5");
    HTTPClient.println("Connection: close");
    HTTPClient.println();
    HTTPClient.stop();
  }
}
void blesend(byte b) {
  if (bletime == -1)
    bletime = millis();
  blemess = b;
  //bleswitch = millis();
  blebool = !blebool;
  Serial.println("blestart");
  uint8_t mdata[30];
  uint8_t bdata[][24] = {{
      0x58, 0x55, 0x18, 0xf9, 0x08, 0x49, 0xb2, 0xce, 0x2c, 0x93, 0x57, 0xf9, 0xfc, 0x65, 0x15, 0x91, 0x51, 0xdc, 0x63, 0x10, 0x11, 0x12, 0x13//, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19//on
    }, {
      0x58, 0x55, 0x18, 0x48, 0x46, 0x4b, 0x4a, 0x51, 0x02, 0xca, 0x59, 0xe4, 0x82, 0xac, 0x23, 0xb2, 0xf0, 0x62, 0xb6, 0xab, 0xe1, 0xf9, 0x55//, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15
    }, {
      0x58, 0x55, 0x18, 0x48, 0x46, 0x4b, 0x4a, 0x69, 0x3d, 0x01, 0x71, 0x0c, 0x6a, 0x94, 0xca, 0xca, 0x60, 0x11, 0x16, 0x3b, 0x01, 0x80, 0x4c//, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15//off
    }, {
      0x58, 0x55, 0x18, 0xf9, 0x08, 0x49, 0xb2, 0xce, 0x2c, 0xa2, 0x66, 0xc8, 0xcd, 0x55, 0x24, 0x91, 0x60, 0x90, 0xea, 0x10, 0x11, 0x12, 0x13//, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19
    }/*, {
      0x58, 0x55, 0x18, 0x48, 0x46, 0x4b, 0x4a, 0x0a, 0x74, 0x3a, 0x10, 0xad, 0xc9, 0xf3, 0x79, 0x6b, 0xb1, 0x1c, 0xca, 0xf0, 0xb0, 0x38, 0xe4, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15//led
    }, {
      0x58, 0x55, 0x18, 0x48, 0x46, 0x4b, 0x4a, 0x9e, 0xdc, 0xa2, 0xa4, 0x41, 0x35, 0x5f, 0xe6, 0xff, 0xcb, 0xd2, 0xe8, 0xed, 0xbe, 0x81, 0x13, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15//Мин
    }, {
      0x58, 0x55, 0x18, 0xf9, 0x08, 0x49, 0xb2, 0xce, 0x2c, 0x94, 0x50, 0xfe, 0x04, 0x72, 0x12, 0x91, 0x56, 0xa7, 0x8d, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19//Макс
    }, {
      0x70, 0x55, 0x18, 0x87, 0x52, 0xb6, 0x5f, 0x2b, 0x5e, 0x00, 0xfc, 0x31, 0x51, 0xd0, 0xb9, 0x17, 0x06, 0x24, 0xcb, 0x62, 0xfc, 0xa7, 0x75, 0x71, 0x83, 0xcf, 0x4b, 0x1e, 0xba//Зал он
    }, {
      0x70, 0x55, 0x18, 0x87, 0x52, 0xb6, 0x5f, 0x2b, 0x5e, 0x00, 0xfc, 0x31, 0x51, 0x50, 0xb9, 0x17, 0x08, 0x24, 0xcb, 0xee, 0xfc, 0x83, 0x51, 0xcb, 0xa7, 0x71, 0x13, 0x0b, 0xfe//Зал off
    }*/
  };
  if (blebool) {
    Serial.println(b * 2 + 1);
  } else {
    Serial.println(b * 2);
  };
  if (b == 0)au[1] = true;
  if (b == 1)au[1] = false;

  for (byte i = 0; i < 24; i++) {
    if (blebool) {
      mdata[i] = bdata[b * 2 + 1][i];
    } else {
      mdata[i] = bdata[b * 2][i];
    };
    mdata[24] = random(255);
    mdata[25] = random(255);
    mdata[26] = random(255);
    mdata[27] = random(255);
    mdata[28] = random(255);
    mdata[29] = random(255);
  }
  /*if (b == 0) {
    uint8_t mdata[30] = {
      0x58, 0x55, 0x18, 0x48, 0x46, 0x4b, 0x4a, 0x69, 0x3d, 0x01, 0x71, 0x0c, 0x6a, 0x94, 0xcb, 0xca, 0x60, 0x11, 0x16, 0x3b, 0x01, 0xe0, 0x07, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15//on
    };
    }
    else if (b == 1) {
    uint8_t mdata[30] = {
      0x58, 0x55, 0x18, 0x48, 0x46, 0x4b, 0x4a, 0x69, 0x3d, 0x01, 0x71, 0x0c, 0x6a, 0x94, 0xca, 0xca, 0x60, 0x11, 0x16, 0x3b, 0x01, 0x80, 0x4c, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15//off
    };
    }
    else if (b == 2) {
    uint8_t mdata[30] = {
      0x58, 0x55, 0x18, 0x48, 0x46, 0x4b, 0x4a, 0x0a, 0x74, 0x3a, 0x10, 0xad, 0xc9, 0xf3, 0x79, 0x6b, 0xb1, 0x1c, 0xca, 0xf0, 0xb0, 0x38, 0xe4, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15//led
    };
    }
    else if (b == 3) {
    uint8_t mdata[30] = {
      0x58, 0x55, 0x18, 0x48, 0x46, 0x4b, 0x4a, 0x9e, 0xdc, 0xa2, 0xa4, 0x41, 0x35, 0x5f, 0xe6, 0xff, 0xcb, 0xd2, 0xe8, 0xed, 0xbe, 0x81, 0x13, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15//Мин
    };
    }
    else if (b == 4) {
    uint8_t mdata[30] = {
      0x58, 0x55, 0x18, 0xf9, 0x08, 0x49, 0xb2, 0xce, 0x2c, 0x94, 0x50, 0xfe, 0x04, 0x72, 0x12, 0x91, 0x56, 0xa7, 0x8d, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19//Макс
    };
    }
    else if (b == 5) {
    uint8_t mdata[30] = {
      0x70, 0x55, 0x18, 0x87, 0x52, 0xb6, 0x5f, 0x2b, 0x5e, 0x00, 0xfc, 0x31, 0x51, 0xd0, 0xb9, 0x17, 0x06, 0x24, 0xcb, 0x62, 0xfc, 0xa7, 0x75, 0x71, 0x83, 0xcf, 0x4b, 0x1e, 0xba//Зал он
    };
    }
    else if (b == 6) {
    uint8_t mdata[30] = {
      0x70, 0x55, 0x18, 0x87, 0x52, 0xb6, 0x5f, 0x2b, 0x5e, 0x00, 0xfc, 0x31, 0x51, 0x50, 0xb9, 0x17, 0x08, 0x24, 0xcb, 0xee, 0xfc, 0x83, 0x51, 0xcb, 0xa7, 0x71, 0x13, 0x0b, 0xfe//Зал off
    };
    }
    else
    uint8_t mdata[30] = {
    0x70, 0x55, 0x18, 0x87, 0x52, 0xb6, 0x5f, 0x2b, 0x5e, 0x00, 0xfc, 0x31, 0x51, 0x50, 0xb9, 0x17, 0x08, 0x24, 0xcb, 0xee, 0xfc, 0x83, 0x51, 0xcb, 0xa7, 0x71, 0x13, 0x0b, 0xfe//Зал off
    };*/

  esp_ble_adv_data_t adata = {
    .set_scan_rsp = false,
    .include_name = false,
    .include_txpower = false,
    .min_interval = 0x00,
    .max_interval = 0x00,
    .appearance = 0x00,
    .manufacturer_len = 29,//sizeof(mdata),
    .p_manufacturer_data = mdata,
    .service_data_len = 0,
    .p_service_data = nullptr,
    .service_uuid_len = 0,
    .p_service_uuid = nullptr
  };
  esp_ble_adv_params_t aparam = {
    .adv_int_min = 0x20,
    .adv_int_max = 0x40,
    .adv_type = ADV_TYPE_IND,
    .own_addr_type = BLE_ADDR_TYPE_PUBLIC,
    .peer_addr = { 0x66, 0x55, 0x44, 0x33, 0x22, 0x11 },
    .peer_addr_type = BLE_ADDR_TYPE_PUBLIC,
    .channel_map = ADV_CHNL_ALL,
    .adv_filter_policy = ADV_FILTER_ALLOW_SCAN_ANY_CON_ANY
  };
  esp_ble_gap_config_adv_data(&adata);
  esp_ble_gap_start_advertising(&aparam);
}
